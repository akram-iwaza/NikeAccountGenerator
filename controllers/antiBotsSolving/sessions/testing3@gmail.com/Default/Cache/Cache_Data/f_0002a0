{"version":3,"sources":["webpack:////tmp/jenkins/workspace/nts_nike_shop-components_1.153.0/.yarn/__virtual__/focus-trap-react-virtual-cbcc0e4769/0/cache/focus-trap-react-npm-8.8.1-04f2bb14d1-27953bf097.zip/node_modules/focus-trap-react/dist/focus-trap-react.js","webpack:////tmp/jenkins/workspace/nts_nike_shop-components_1.153.0/.yarn/cache/@babel-runtime-npm-7.16.7-62d4d1151f-47912f0aaa.zip/node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack:////tmp/jenkins/workspace/nts_nike_shop-components_1.153.0/.yarn/cache/@babel-runtime-npm-7.16.7-62d4d1151f-47912f0aaa.zip/node_modules/@babel/runtime/helpers/createClass.js","webpack:////tmp/jenkins/workspace/nts_nike_shop-components_1.153.0/.yarn/cache/@babel-runtime-npm-7.16.7-62d4d1151f-47912f0aaa.zip/node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack:////tmp/jenkins/workspace/nts_nike_shop-components_1.153.0/.yarn/cache/@babel-runtime-npm-7.16.7-62d4d1151f-47912f0aaa.zip/node_modules/@babel/runtime/helpers/inherits.js","webpack:////tmp/jenkins/workspace/nts_nike_shop-components_1.153.0/.yarn/cache/@babel-runtime-npm-7.16.7-62d4d1151f-47912f0aaa.zip/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack:////tmp/jenkins/workspace/nts_nike_shop-components_1.153.0/.yarn/cache/@babel-runtime-npm-7.16.7-62d4d1151f-47912f0aaa.zip/node_modules/@babel/runtime/helpers/typeof.js","webpack:////tmp/jenkins/workspace/nts_nike_shop-components_1.153.0/.yarn/cache/focus-trap-npm-6.7.1-eef144bbc9-b96c54a6a2.zip/node_modules/focus-trap/dist/focus-trap.esm.js","webpack:////tmp/jenkins/workspace/nts_nike_shop-components_1.153.0/.yarn/cache/tabbable-npm-5.2.1-6c5c4b34fa-d26e9eeb88.zip/node_modules/tabbable/dist/index.esm.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","call","e","_createSuperInternal","result","Super","_getPrototypeOf","NewTarget","this","arguments","apply","_possibleConstructorReturn","self","TypeError","_assertThisInitialized","ReferenceError","getPrototypeOf","React","ReactDOM","PropTypes","createFocusTrap","FocusTrap","_React$Component","_inherits","subClass","superClass","create","value","_super","_this","_classCallCheck","instance","Constructor","tailoredFocusTrapOptions","returnFocusOnDeactivate","focusTrapOptions","optionName","hasOwnProperty","onPostDeactivate","focusTrapElements","containerElements","updatePreviousElement","_createClass","protoProps","staticProps","getNodeForOption","optionValue","node","document","querySelector","Error","concat","getReturnFocusNode","previouslyFocusedElement","currentDocument","undefined","activeElement","deactivateTrap","_this2","checkCanReturnFocus","focusTrap","deactivate","returnFocus","finishDeactivation","returnFocusNode","focus","then","setupFocusTrap","focusTrapElementDOMNodes","map","findDOMNode","some","_createFocusTrap","active","activate","paused","pause","componentDidMount","componentDidUpdate","prevProps","updateContainerElements","hasActivated","hasDeactivated","hasPaused","hasUnpaused","unpause","componentWillUnmount","render","_this3","child","children","Children","only","type","Fragment","cloneElement","ref","composedRefCallback","element","current","Component","ElementType","Element","Function","propTypes","bool","shape","object","onActivate","func","onPostActivate","checkCanFocusTrap","onDeactivate","initialFocus","oneOfType","instanceOf","string","fallbackFocus","escapeDeactivates","clickOutsideDeactivates","setReturnFocus","allowOutsideClick","preventScroll","arrayOf","defaultProps","module","exports","__esModule","assertThisInitialized","ownKeys","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","_defineProperty","trapQueue","activeFocusTraps","activateTrap","trap","activeTrap","trapIndex","indexOf","splice","delay","fn","setTimeout","findIndex","arr","idx","every","valueOrHandler","_len","params","Array","_key","getActualTarget","event","shadowRoot","composedPath","elements","userOptions","doc","config","_objectSpread2","source","forEach","getOwnPropertyDescriptors","defineProperties","delayInitialFocus","state","containers","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","delayInitialFocusTimer","getOption","configOverrideOptions","configOptionName","containersContain","container","contains","_len2","_key2","getInitialFocusNode","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","tabbableNodes","lastTabbableNode","group","tryFocus","isSelectableInput","tagName","toLowerCase","select","previousActiveElement","checkPointerDown","preventDefault","checkFocusIn","targetContained","Document","stopImmediatePropagation","checkKey","isEscapeEvent","keyCode","isTabEvent","checkTab","destinationNode","containerIndex","_ref","shiftKey","startOfGroupIndex","_ref2","destinationGroupIndex","lastOfGroupIndex","_ref3","_destinationGroupIndex","checkClick","addListeners","addEventListener","capture","passive","removeListeners","removeEventListener","activateOptions","finishActivation","deactivateOptions","clearTimeout","elementsAsArray","candidateSelectors","candidateSelector","join","matches","msMatchesSelector","webkitMatchesSelector","getCandidates","el","includeContainer","candidates","slice","querySelectorAll","unshift","getTabindex","tabindexAttr","parseInt","getAttribute","isNaN","isContentEditable","contentEditable","nodeName","tabIndex","sortOrderedTabbables","a","b","documentOrder","isInput","isNonTabbableRadio","isRadio","isTabbableRadio","name","radioSet","radioScope","form","ownerDocument","queryRadios","window","CSS","escape","err","console","error","message","checked","getCheckedRadio","nodes","isNodeMatchingSelectorFocusable","options","disabled","isHiddenInput","isHidden","displayCheck","getComputedStyle","visibility","nodeUnderDetails","parentElement","_node$getBoundingClie","getBoundingClientRect","width","height","display","isDetailsWithSummary","isDisabledFromFieldset","parentNode","item","isNodeMatchingSelectorTabbable","tabbable","regularTabbables","orderedTabbables","bind","candidate","candidateTabindex","sort","focusable","isTabbable","focusableCandidateSelector","isFocusable"],"mappings":"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","file":"vendors~Dialog.chunk.c5ce2c.js","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar React = require('react');\n\nvar ReactDOM = require('react-dom');\n\nvar PropTypes = require('prop-types');\n\nvar _require = require('focus-trap'),\n    createFocusTrap = _require.createFocusTrap; // TODO: These issues are related to older React features which we'll likely need\n//  to fix in order to move the code forward to the next major version of React.\n//  @see https://github.com/davidtheclark/focus-trap-react/issues/77\n\n/* eslint-disable react/no-find-dom-node */\n\n\nvar FocusTrap = /*#__PURE__*/function (_React$Component) {\n  _inherits(FocusTrap, _React$Component);\n\n  var _super = _createSuper(FocusTrap);\n\n  function FocusTrap(props) {\n    var _this;\n\n    _classCallCheck(this, FocusTrap);\n\n    _this = _super.call(this, props); // We need to hijack the returnFocusOnDeactivate option,\n    // because React can move focus into the element before we arrived at\n    // this lifecycle hook (e.g. with autoFocus inputs). So the component\n    // captures the previouslyFocusedElement in componentWillMount,\n    // then (optionally) returns focus to it in componentWillUnmount.\n\n    _this.tailoredFocusTrapOptions = {\n      returnFocusOnDeactivate: false\n    }; // because of the above, we maintain our own flag for this option, and\n    //  default it to `true` because that's focus-trap's default\n\n    _this.returnFocusOnDeactivate = true;\n    var focusTrapOptions = props.focusTrapOptions;\n\n    for (var optionName in focusTrapOptions) {\n      if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {\n        continue;\n      }\n\n      if (optionName === 'returnFocusOnDeactivate') {\n        _this.returnFocusOnDeactivate = !!focusTrapOptions[optionName];\n        continue;\n      }\n\n      if (optionName === 'onPostDeactivate') {\n        _this.onPostDeactivate = focusTrapOptions[optionName];\n        continue;\n      }\n\n      _this.tailoredFocusTrapOptions[optionName] = focusTrapOptions[optionName];\n    } // elements from which to create the focus trap on mount; if a child is used\n    //  instead of the `containerElements` prop, we'll get the child's related\n    //  element when the trap renders and then is declared 'mounted'\n\n\n    _this.focusTrapElements = props.containerElements || []; // now we remember what the currently focused element is, not relying on focus-trap\n\n    _this.updatePreviousElement();\n\n    return _this;\n  } // TODO: Need more test coverage for this function\n\n\n  _createClass(FocusTrap, [{\n    key: \"getNodeForOption\",\n    value: function getNodeForOption(optionName) {\n      var optionValue = this.tailoredFocusTrapOptions[optionName];\n\n      if (!optionValue) {\n        return null;\n      }\n\n      var node = optionValue;\n\n      if (typeof optionValue === 'string') {\n        node = document.querySelector(optionValue);\n\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` refers to no known node\"));\n        }\n      }\n\n      if (typeof optionValue === 'function') {\n        node = optionValue();\n\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` did not return a node\"));\n        }\n      }\n\n      return node;\n    }\n  }, {\n    key: \"getReturnFocusNode\",\n    value: function getReturnFocusNode() {\n      var node = this.getNodeForOption('setReturnFocus');\n      return node ? node : this.previouslyFocusedElement;\n    }\n    /** Update the previously focused element with the currently focused element. */\n\n  }, {\n    key: \"updatePreviousElement\",\n    value: function updatePreviousElement() {\n      // SSR: careful to check if `document` exists before accessing it as a variable\n      var currentDocument = this.props.focusTrapOptions.document || (typeof document !== 'undefined' ? document : undefined);\n\n      if (currentDocument) {\n        this.previouslyFocusedElement = currentDocument.activeElement;\n      }\n    }\n  }, {\n    key: \"deactivateTrap\",\n    value: function deactivateTrap() {\n      var _this2 = this;\n\n      var checkCanReturnFocus = this.tailoredFocusTrapOptions.checkCanReturnFocus;\n\n      if (this.focusTrap) {\n        // NOTE: we never let the trap return the focus since we do that ourselves\n        this.focusTrap.deactivate({\n          returnFocus: false\n        });\n      }\n\n      var finishDeactivation = function finishDeactivation() {\n        var returnFocusNode = _this2.getReturnFocusNode();\n\n        var canReturnFocus = (returnFocusNode === null || returnFocusNode === void 0 ? void 0 : returnFocusNode.focus) && _this2.returnFocusOnDeactivate;\n\n        if (canReturnFocus) {\n          /** Returns focus to the element that had focus when the trap was activated. */\n          returnFocusNode.focus();\n        }\n\n        if (_this2.onPostDeactivate) {\n          _this2.onPostDeactivate.call(null); // don't call it in context of \"this\"\n\n        }\n      };\n\n      if (checkCanReturnFocus) {\n        checkCanReturnFocus(this.getReturnFocusNode()).then(finishDeactivation, finishDeactivation);\n      } else {\n        finishDeactivation();\n      }\n    }\n  }, {\n    key: \"setupFocusTrap\",\n    value: function setupFocusTrap() {\n      if (!this.focusTrap) {\n        var focusTrapElementDOMNodes = this.focusTrapElements.map( // NOTE: `findDOMNode()` does not support CSS selectors; it'll just return\n        //  a new text node with the text wrapped in it instead of treating the\n        //  string as a selector and resolving it to a node in the DOM\n        ReactDOM.findDOMNode);\n        var nodesExist = focusTrapElementDOMNodes.some(Boolean);\n\n        if (nodesExist) {\n          // eslint-disable-next-line react/prop-types -- _createFocusTrap is an internal prop\n          this.focusTrap = this.props._createFocusTrap(focusTrapElementDOMNodes, this.tailoredFocusTrapOptions);\n\n          if (this.props.active) {\n            this.focusTrap.activate();\n          }\n\n          if (this.props.paused) {\n            this.focusTrap.pause();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.setupFocusTrap();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.focusTrap) {\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrap.updateContainerElements(this.props.containerElements);\n        }\n\n        var hasActivated = !prevProps.active && this.props.active;\n        var hasDeactivated = prevProps.active && !this.props.active;\n        var hasPaused = !prevProps.paused && this.props.paused;\n        var hasUnpaused = prevProps.paused && !this.props.paused;\n\n        if (hasActivated) {\n          this.updatePreviousElement();\n          this.focusTrap.activate();\n        }\n\n        if (hasDeactivated) {\n          this.deactivateTrap();\n          return; // un/pause does nothing on an inactive trap\n        }\n\n        if (hasPaused) {\n          this.focusTrap.pause();\n        }\n\n        if (hasUnpaused) {\n          this.focusTrap.unpause();\n        }\n      } else if (prevProps.containerElements !== this.props.containerElements) {\n        this.focusTrapElements = this.props.containerElements;\n        this.setupFocusTrap();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var child = this.props.children ? React.Children.only(this.props.children) : undefined;\n\n      if (child) {\n        if (child.type && child.type === React.Fragment) {\n          throw new Error('A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.');\n        }\n\n        var composedRefCallback = function composedRefCallback(element) {\n          var containerElements = _this3.props.containerElements;\n\n          if (child) {\n            if (typeof child.ref === 'function') {\n              child.ref(element);\n            } else if (child.ref) {\n              child.ref.current = element;\n            }\n          }\n\n          _this3.focusTrapElements = containerElements ? containerElements : [element];\n        };\n\n        var childWithRef = React.cloneElement(child, {\n          ref: composedRefCallback\n        });\n        return childWithRef;\n      }\n\n      return null;\n    }\n  }]);\n\n  return FocusTrap;\n}(React.Component); // support server-side rendering where `Element` will not be defined\n\n\nvar ElementType = typeof Element === 'undefined' ? Function : Element;\nFocusTrap.propTypes = {\n  active: PropTypes.bool,\n  paused: PropTypes.bool,\n  focusTrapOptions: PropTypes.shape({\n    document: PropTypes.object,\n    onActivate: PropTypes.func,\n    onPostActivate: PropTypes.func,\n    checkCanFocusTrap: PropTypes.func,\n    onDeactivate: PropTypes.func,\n    onPostDeactivate: PropTypes.func,\n    checkCanReturnFocus: PropTypes.func,\n    initialFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func, PropTypes.bool]),\n    fallbackFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func]),\n    escapeDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    clickOutsideDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    returnFocusOnDeactivate: PropTypes.bool,\n    setReturnFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func]),\n    allowOutsideClick: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    preventScroll: PropTypes.bool\n  }),\n  containerElements: PropTypes.arrayOf(PropTypes.instanceOf(ElementType)),\n  children: PropTypes.oneOfType([PropTypes.element, // React element\n  PropTypes.instanceOf(ElementType) // DOM element\n  ]) // NOTE: _createFocusTrap is internal, for testing purposes only, so we don't\n  //  specify it here. It's expected to be set to the function returned from\n  //  require('focus-trap'), or one with a compatible interface.\n\n};\nFocusTrap.defaultProps = {\n  active: true,\n  paused: false,\n  focusTrapOptions: {},\n  _createFocusTrap: createFocusTrap\n};\nmodule.exports = FocusTrap;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var setPrototypeOf = require(\"./setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\n\nvar assertThisInitialized = require(\"./assertThisInitialized.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\n\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","/*!\n* focus-trap 6.7.1\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { tabbable, isFocusable } from 'tabbable';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar activeFocusTraps = function () {\n  var trapQueue = [];\n  return {\n    activateTrap: function activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n    deactivateTrap: function deactivateTrap(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n}();\n\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\n\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nvar isTabEvent = function isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n}; // Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\n\n\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n  return idx;\n};\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\n\n\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\n\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true\n  }, userOptions);\n\n  var state = {\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying the first and last tabbable nodes in all containers/groups in\n    //  the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{ container: HTMLElement, firstTabbableNode: HTMLElement|null, lastTabbableNode: HTMLElement|null }>}\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  var containersContain = function containersContain(element) {\n    return !!(element && state.containers.some(function (container) {\n      return container.contains(element);\n    }));\n  };\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n\n\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n\n      optionValue = optionValue.apply(void 0, params);\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      } // else, empty string (invalid), null (invalid), 0 (invalid)\n\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n\n    return node;\n  };\n\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus'); // false explicitly indicates we want no initialFocus at all\n\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (containersContain(doc.activeElement)) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode; // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n\n    return node;\n  };\n\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.tabbableGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container);\n\n      if (tabbableNodes.length > 0) {\n        return {\n          container: container,\n          firstTabbableNode: tabbableNodes[0],\n          lastTabbableNode: tabbableNodes[tabbableNodes.length - 1]\n        };\n      }\n\n      return undefined;\n    }).filter(function (group) {\n      return !!group;\n    }); // remove groups with no tabbable nodes\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n  };\n\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  }; // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n\n\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n\n    if (containersContain(target)) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target)\n      });\n      return;\n    } // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    } // otherwise, prevent the click\n\n\n    e.preventDefault();\n  }; // In case focus escapes the trap for some strange reason, pull it back in.\n\n\n  var checkFocusIn = function checkFocusIn(e) {\n    var target = getActualTarget(e);\n    var targetContained = containersContain(target); // In Firefox when you Tab out of an iframe the Document is briefly focused.\n\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  }; // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n\n\n  var checkTab = function checkTab(e) {\n    var target = getActualTarget(e);\n    updateTabbableNodes();\n    var destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's tabbable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findIndex(state.tabbableGroups, function (_ref) {\n        var container = _ref.container;\n        return container.contains(target);\n      });\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {\n          var firstTabbableNode = _ref2.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n\n        if (startOfGroupIndex < 0 && state.tabbableGroups[containerIndex].container === target) {\n          // an exception case where the target is the container itself, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var lastTabbableNode = _ref3.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n\n        if (lastOfGroupIndex < 0 && state.tabbableGroups[containerIndex].container === target) {\n          // an exception case where the target is the container itself, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = _destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    } // else, let the browser take care of [shift+]tab and move the focus\n\n  };\n\n  var checkKey = function checkKey(e) {\n    if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  var checkClick = function checkClick(e) {\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    var target = getActualTarget(e);\n\n    if (containersContain(target)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }; //\n  // EVENT LISTENERS\n  //\n\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    } // There can be only one listening focus trap at a time\n\n\n    activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  }; //\n  // TRAP DEFINITION\n  //\n\n\n  trap = {\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n\n        addListeners();\n\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      activeFocusTraps.deactivateTrap(trap);\n      var onDeactivate = getOption(deactivateOptions, 'onDeactivate');\n      var onPostDeactivate = getOption(deactivateOptions, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(deactivateOptions, 'checkCanReturnFocus');\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      var returnFocus = getOption(deactivateOptions, 'returnFocus', 'returnFocusOnDeactivate');\n\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n      return this;\n    },\n    unpause: function unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    }\n  }; // initialize container elements\n\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","/*!\n* tabbable 5.2.1\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\nvar isContentEditable = function isContentEditable(node) {\n  return node.contentEditable === 'true';\n};\n\nvar getTabindex = function getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  } // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n\n  if (isContentEditable(node)) {\n    return 0;\n  } // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0.\n\n\n  if ((node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {\n    return 0;\n  }\n\n  return node.tabIndex;\n};\n\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\n\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\n\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\n\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || node.ownerDocument;\n\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n\n  var radioSet;\n\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nvar isHidden = function isHidden(node, displayCheck) {\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  if (!displayCheck || displayCheck === 'full') {\n    while (node) {\n      if (getComputedStyle(node).display === 'none') {\n        return true;\n      }\n\n      node = node.parentElement;\n    }\n  } else if (displayCheck === 'non-zero-area') {\n    var _node$getBoundingClie = node.getBoundingClientRect(),\n        width = _node$getBoundingClie.width,\n        height = _node$getBoundingClie.height;\n\n    return width === 0 && height === 0;\n  }\n\n  return false;\n}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\n\n\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (isInput(node) || node.tagName === 'SELECT' || node.tagName === 'TEXTAREA' || node.tagName === 'BUTTON') {\n    var parentNode = node.parentElement;\n\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> as an immediate child of the disabled\n        //  <fieldset>: if the node is in that legend, it'll be enabled even\n        //  though the fieldset is disabled; otherwise, the node is in a\n        //  secondary/subsequent legend, or somewhere else within the fieldset\n        //  (however deep nested) and it'll be disabled\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n\n          if (child.tagName === 'LEGEND') {\n            if (child.contains(node)) {\n              return false;\n            } // the node isn't in the first legend (in doc order), so no matter\n            //  where it is now, it'll be disabled\n\n\n            return true;\n          }\n        } // the node isn't in a legend, so no matter where it is now, it'll be disabled\n\n\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  } // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n\n\n  return false;\n};\n\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options.displayCheck) || // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (!isNodeMatchingSelectorFocusable(options, node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  candidates.forEach(function (candidate, i) {\n    var candidateTabindex = getTabindex(candidate);\n\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate\n      });\n    }\n  });\n  var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {\n    return a.node;\n  }).concat(regularTabbables);\n  return tabbableNodes;\n};\n\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  return candidates;\n};\n\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n"],"sourceRoot":""}